Chapter 3 - FAQ
===============

!include "guide/menu.inc"

What is the meaning of G0 and G1?
---------------------------------
G0 defines exactly what tokens are acceptable in the input stream. So, these are the rules defining the
syntax of the tokens, but not the syntax of how these tokens can be combined.

G1 defines the structure of the language. These rules define legal statements within the given language.
Legal statements are thus legal combinations of tokens.

Also, G1 rules have a semantics, whereas G0 rules do not.

G0 and G1 discussed in [Marpa::R2::Scanless::DSL](https://metacpan.org/release/Marpa-R2), and, very
briefly, in [Marpa::R2::Semantics](https://metacpan.org/release/Marpa-R2). In both cases, search for 'G0'.

How do I parse numbers?
-----------------------
Chapter 2 discusses this issue at length. And if you fork the project on github, you'll find the directory
examples/ contains about a dozen sample programs.

Alternately, download [MarpaX::Languages::SVG::Parser](https://metacpan.org/release/MarpaX-Languages-SVG-Parser),
which contains similar logic (in data/*.bnf). Further, the distro includes sample code (float.pl and number.pl)
in the scripts/ directory. The last-named script includes grammars for binary, octal and hex numbers.

How do I represent choice in the grammar?
-----------------------------------------
Briefly, use '|'. Sample code from the above named module (data/d.bnf):

	coordinate  ::= float      action => float
	                | integer  action => integer

Also note that '||' is available to control the relative priorities of the alternatives. This issue is expanded
in a later item in this FAQ.

See also the next item.

Is there any other way of representing choice?
----------------------------------------------
Sure. Consider these G0 rules (also from data/d.bnf):

	sign_maybe  ~ [+-]
	sign_maybe  ~

	digit       ~ [0-9]
	digit_any   ~ digit*
	digit_many  ~ digit+

	E           ~ [Ee] sign_maybe digit_many
	E_maybe     ~ E
	E_maybe     ~

	:lexeme     ~ float
	float       ~ sign_maybe digit_many E
	              | sign_maybe digit_any '.' digit_many E_maybe
	              | sign_maybe digit_many '.' E_maybe
	              | sign_maybe non_zero digit_any

This is saying:

* The sign is optional after E or e (sign_maybe)

* The E is optional (E_maybe)

* The sign is optional before a digit (the first alternative for 'float')

* And so on

What does it mean to hide (mask) tokens?
-----------------------------------------
It's possible to design a grammar such that we can say certain tokens are hidden. This is discussed in the docs
for [Marpa::R2::Scanless::DSL](https://metacpan.org/release/Marpa-R2).

Here is an example (from [Graph::Easy::Marpa::Parser](https://metacpan.org/release/Graph-Easy-Marpa-Parser)):

	node_definition  ::= node_statement
	                 | node_statement graph_definition

	node_statement   ::= node_name
	                 | node_name attribute_definition
	                 | node_statement (',') node_statement

	node_name        ::= start_node end_node

	:lexeme          ~ start_node  pause => before  event => start_node
	start_node       ~ '['

	:lexeme          ~ end_node
	end_node         ~ ']'

The comma is hidden. But what does this mean, exactly?

It means the comma may appear in the input stream (in this context), but I am not interested in it. So, Marpa will not
return this token to me when an action is called. It has become invisible to the semantics.

Semantics are documented in [Marpa::R2::Semantics](https://metacpan.org/release/Marpa-R2).

Close study of the above grammar will show that another path is possible thru the grammar, in the case of
2 nodes side-by-side (i.e. without a comma between them). Thus the grammar accepts both these input streams
as valid:

	Stream 1: [node.a], [node.b]
	Stream 2: [node.a]  [node.b]

Hence, from the end-user's viewpoint, the comma is defined - at least in this particular grammar - to be optional.

What's the difference between '|' and '||' in grammar definitions?
------------------------------------------------------------------
'|' expresses a simple alternative, while '||' separates alternatives at different levels of precedence. For example:

	E ::=    E '*' E
	      |  E '/' E
	      || E '+' E
	      |  E '-' E

This describes syntax for a simple 4-operation calculator, where multiplication and division take precedence over
addition and subtraction.

This construct forces alternatives before the '||' to have higher precedence than the alternatives after that token.

Each of the alternatives separated by '|' are at the same precedence.

In Mark Dominus's 'Higher-Order Perl' book, he describes how he handles precedence in his recursive descent parsers
for a similar calculator, beginning on p. 394. This is a good description of how the same situation would be handled
with pre-Marpa techniques.

If precedence is not an issue for you, just use single bar alternation ('|').

Note also that Marpa supports a 'priority' adverb, discussed in the
[Marpa::R2::Scanless::DSL](https://metacpan.org/release/Marpa-R2) docs mentioned above.

How to I implement recursion in a grammar?
------------------------------------------
See the next item.

Why does using '+' or '*' in a rule only work sometimes?
--------------------------------------------------------
I assume you're referring to cases like this:

Case 1 (fails):

	node_definition  ::= node_statement+
	                 | node_statement graph_definition

Case 2 (succeeds):

	coordinate_list  ::= coordinate+

Case 3 (succeeds):

	whitespace       ~ [\s]+

Briefly, quantified rules (here, using the '+'), are only allowed when the right-hand side contains a single
alternative. Thus case 1 fails due to the combination of '+' and '|'.

This is documented in [Marpa::R2::Scanless::DSL](https://metacpan.org/release/Marpa-R2), under
'Quantified rules'.

So we must re-write rule 1:

	graph_definition  ::= node_definition
	                  | edge_definition
	                  | subgraph_definition

	node_definition  ::= node_statement
	                 | node_statement graph_definition

	node_statement   ::= node_name
	                 | node_name attribute_definition
	                 | node_statement (',') node_statement

Now the rule 'node_definition ::= node_statement' allows a node definition to consist of a single node statement.

And the alternative - via the '|' - 'node_definition ::= node_statement graph_definition' allows a node
definition to consist of a node statement followed by a graph definition, which just happens to include the line
'graph_definition ::= node_definition'!

So we've managed to write the grammar using indirect recursion, thus allowing an indefinite list of node
definitions to follow one another. And the last rule allows the input stream to separate them with commas as
well as the usual spaces.

How do I find out where I am within the input stream?
-----------------------------------------------------
In the docs for Marpa::R2::Scanless::R, see the line_column() method.

How do I find out which rule applies at some point in the input stream?
-----------------------------------------------------------------------
In the docs for Marpa::R2::Semantics, the section titled 'Action context' shows how to access internal variables in
Marpa which do what you want.

What is the meaning of the line number in a Marpa error message?
----------------------------------------------------------------
It is the line number within the BNF of the rule being processed.

Note: If your grammar uses \r, that will affect the line count.

More specifically, in the docs for Marpa::R2::Scanless::R, under the line_column() method, a range of special characters
are listed.

How do I associate an action class with my grammar?
---------------------------------------------------

Note: The next FAQ item, 'Declaring an Action Class', details a solution to the problems discussed here.

The synopsis in [Marpa::R2::Semantics](https://metacpan.org/release/Marpa-R2) shows one way.
See 'bless_package'.

Another way is to note that the Scanless interface recognizer accepts a 'semantics_package' argument. See
[Marpa::R2::Scanless::R](https://metacpan.org/release/Marpa-R2).

Here's how I declare a recognizer in one package:

	$self -> recce
	(
		Marpa::R2::Scanless::R -> new
		({
			grammar           => $self -> grammar,
			semantics_package => 'MarpaX::Languages::SVG::Parser::Actions',
		})
	);

Now actions referenced in the grammar, as in:

	coordinate  ::= float      action => float
	                | integer  action => integer

must be declared as functions in the named semantics package, and that's where Marpa looks for them.

From an OO point of view though, there is still a problem. After reading the 'The per-parse argument' and
'The per-parse constructor' sections of the semantics document, you might think:

	Marpa calls the constructor of the semantics package (given it has one).
	That means Marpa has an instance of that package.
	That should mean I can get access to that instance.
	So, I can write code in the main-line to communicate between Marpa and this instance.

This immediately raises some questions:

* How do I access that instance?

Under Marpa::R2, you can't.

* If I use Moo to write this action package, what happens?

Presumably you want an instance of the action class to be passed by Marpa as the per-parse (1st) parameter to each
action sub. That's certainly what I've always wanted to do. But...

Don't do that. It works, but turns out to be inherently risky, so don't try it. Alternatives are discussed in the
next FAQ item: 'Declaring an Action Class'.

The problem here is that with [Moo](https://metacpan.org/release/Moo), the new() constructor is generated automatically.
My tests show such a instance is not initialized by Marpa. That is, Marpa cannot find new(), and passes an
unblessed hash into each action sub, as the per-parse (1st) parameter. In short, Moo patches Perl's symbol table, and
Marpa accesses it too, but they don't co-operate as you might hope.

* If I create an instance of the action class, can I pass it to Marpa?

Under Marpa::R2, no, you can't.

* But which instance is Marpa using?

It's own.

* If my action subs accumulate instance-level data, how can I retrieve such data?

(This means, data generated when Marpa calls action subs within its own copy of this instance.)

I don't know, but it 'just works' (with Moo at least). I used to use this code:

	$self -> actions
	(
		MarpaX::Languages::SVG::Parser::Actions -> new(logger => $self -> logger)
	);

along with the initialization of $self -> recce(...) above.

Later, when I used $self -> action to access data within my instance, I'd get the data generated in the calls by Marpa
to my action subs. So, it works.

However, it seems to work accidently, and I feel deeply uneasy about that. And, worse, it could simply stop working
when any of Perl, Moo or Marpa change internally.

* Well, can I use global variables within the action class to gather data generated by action subs?

Yes, but if they are class-level variables, it means you can't run multiple scripts at the same which use that class.
That's a classic problem with global data. The other problem of course is re-initializing the data before the second
run of the same script, or before the first run of any other script. It's ok if you re-run Perl itself, via the
command line say, when you run the next script. But in a persistent environment you won't be doing that. Hence, the
next item in this FAQ.

Declaring an Action Class
-------------------------
The previous item in this FAQ discussed at length various issues regarding how to cleanly generate data within action
subs, and how to pass that data back to the main-line code which called Marpa.

Here I explain the solution I've adopted. Briefly, each action sub returns a _hashref_ to Marpa (since Marpa is the
one calling the subs), and after a successful parse, the result of the parse (returned by the value() method of the
recognizer class) is processed to recover those hashrefs.

There is one basic problem to solve along the way: The data structure Marpa makes available as the result of the parse
can be a deeply nested set of _arrayrefs_, depending on how deeply within the grammar the action sub is named.

Conside this fragment of the SVG grammar from ():

	curve_to			::= Cc curve_to_arguments  action => command

	curve_to_arguments	::= coordinate_triple
	                        | coordinate_triple curve_to_arguments
	...
	coordinate_triple	::= coordinate coordinate coordinate

	coordinate_pair		::= coordinate coordinate

	coordinate_list		::= coordinate+

	coordinate			::= float      action => float
	                        | integer  action => integer



How do I implement disambiguation logic?
----------------------------------------
In the docs for Marpa::R2::Semantics, the section titled 'Bailing out of parse evaluation' discusses how to short-circuit
semantic analysis.

!include "guide/menu.inc"
